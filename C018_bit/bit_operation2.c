#include <stdio.h>

int main()
{
	unsigned char num1 = 240;  //240: 1111 0000
	unsigned char num2 = 15;  //15: 0000 1111
	unsigned char num3, num6;
	unsigned num4 = 131;  //131: 1000 0011
	char num5 = -125;  //-125: 1000 0011
	char num7, num8;
	char num9 = 67;  //67: 0100 0011
	char num10 = 113;  //113: 0111 0001
	char num11 = -15;  //-15: 1111 0001
	char num12, num13;
	unsigned char flag = 0;  //0: 0000 0000

	//비트에서 첫째 자리나 마지막 자리를 넘어서는 비트는 그대로 사라짐 
	num3 = num1 << 2;
	printf("%u\n", num3);  //192: 1100 0000
	printf("%u\n", num2 >> 2);  // 3: 0000 0011
	num6 = num4 >> 5;
	num7 = num5 >> 5;
	printf("%u\n", num6);  //4: 0000 0100
	printf("%d\n", num7);  //-4: 1111 1100: 모자라는 공간은 부호 비트의 값인 1로 채워지므로 111 1100이 됨
	num8 = num9 >> 5;
	printf("%d\n", num8);// 2: 0000 0010: 모자라는 공간은 부호 비트의 값인 0으로 채워짐 
	//부호 있는 자료형에 시프트 연산을 할 때는 의도치 않는 결과가 나올 수 있으므로 항상 부호 비트를 생각해야 함
	num12 = num10 << 2;
	num13 = num11 << 4;
	printf("%d\n", num12);  //-60: 1100 0100: 부호 비트를 덮어쓰게 되므로 양수에서 음수가 됨 
	printf("%d\n", num13);  //16: 0001 0000: 부호 비트를 덮어쓰게 되므로 음수에 양수가 됨
	// 사용할 변수 |= 마스크 값: 마스크 값을 비트로 바꾸어서 1로 만든다.
	flag |= 1;  // 0000 0001 마스그와 비트 OR로 여덟 번쨰 비트를 켬
	flag |= 2;  // 0000 0010 마스그와 비트 OR로 일곱 번쨰 비트를 켬
	flag |= 4;  // 0000 0100 마스그와 비트 OR로 여섯 번쨰 비트를 켬
	printf("%u\n", flag);  //7: 0000 0111
	if (flag & 1)  //& 연산자로 0000 0001비트가 켜져 있는지 확인
	{
		printf("0000 0001은 켜져 있음\n");
	}
	else
	{
		printf("0000 0001은 꺼져 있음\n");
	}

	flag &= ~2;  //1111 1101: 마스크 값2(0000 0010)의 비트를 뒤집은 뒤 비트 AND로 일곱 번째 비트를 끔
	if (flag & 2)
	{
		printf("0000 0010은 껴져 있음\n");
	}
	else
	{
		printf("0000 0010은 꺼져 있음\n");
	}

	//flag = 0000 0101
	flag ^= 8;  //0000 1000마스크와 비트 XOR로 다섯 번째 비트를 토글
	printf("%u\n", flag);
	//flag = 0000 1101
	//비트가 껴져 있다면 끄고, 꺼져있다면 켜는 방법입니다. 다른 말로는 토글(toggle)이라고도 합니다. 
	if (flag & 1)
	{
		printf("0000 0001은 껴져 있음\n");
	}
	else
	{
		printf("0000 0001은 꺼져 있음\n");
	}
	return 0;
}
